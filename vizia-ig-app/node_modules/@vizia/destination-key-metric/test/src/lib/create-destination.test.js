'use strict';

const test = require('ava');
const SandboxedModule = require('sandboxed-module');
const sinon = require('sinon');

function requireCreateDestination() {
    const sandbox = sinon.createSandbox();
    const stubs = {};

    stubs.App = sandbox.stub();
    stubs.app = {
        updateData: sinon.stub(),
        updateConfig: sinon.stub()
    };

    stubs.App.returns(stubs.app);

    return Object.assign(SandboxedModule.require('../../../src/lib/create-destination', {
        requires: {
            './app': stubs.App
        }
    }), {sandbox, stubs});
}

test('Creating a destination', (t) => {
    const createDestination = requireCreateDestination();
    const destination = createDestination();

    t.true(createDestination.stubs.App.calledWithNew(), 'instantiates an App');
    t.deepEqual(
        Object.keys(destination),
        ['destination'],
        'instance is a pipeline compatible object'
    );
    t.is(
        typeof destination.destination,
        'function',
        'instance.destination is a function'
    );
});

test('Pushing data to destination', (t) => {
    const createDestination = requireCreateDestination();
    const inputFixture = {
        value: 1
    };
    const optionsFixture = {
        foo: 'bar'
    };
    const configFixture = {
        destTarget: '#bundle-container'
    };
    const mockPipeline = {
        config: configFixture,
        done: createDestination.sandbox.stub()
    };
    const destination = createDestination(optionsFixture);

    destination.destination(inputFixture, mockPipeline);

    t.deepEqual(
        createDestination.stubs.app.updateData.getCall(0).args[0],
        inputFixture,
        'invoked app.updateData with data'
    );
    t.deepEqual(
        createDestination.stubs.app.updateConfig.getCall(0).args[0],
        Object.assign({}, optionsFixture, configFixture),
        'invoked app.updateConfig with merged pipeline config and options'
    );
    t.true(mockPipeline.done.called, 'invokes pipeline.done');
});
