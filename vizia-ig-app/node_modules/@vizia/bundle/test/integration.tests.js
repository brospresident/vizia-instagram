'use strict';

const test = require('ava');
const Bundle = require('../lib/Bundle');

test.cb('one-shot with source that calls `pipeline.done`', (t) => {
    const items = [];
    function source(pipeline) {
        let count = 0;
        const iv = setInterval(() => {
            pipeline.push(count += 1);
            if (count === 2) {
                clearInterval(iv);
                pipeline.done();
            }
        }, 200);
    }

    function destination(data, pipeline) {
        items.push(data);
        pipeline.done();
    }

    const bundle = new Bundle();
    bundle.use({source});
    bundle.use({destination});

    bundle.on('end', () => {
        t.is(items.length, 2, 'received 2 items in total');
        t.is(items[0], 1, 'first item was correct');
        t.is(items[1], 2, 'second item was correct');

        t.end();
    });

    bundle.start();

    t.plan(3);
});

test.cb('loop with source that calls `pipeline.done`', (t) => {
    const items = [];
    function source(pipeline) {
        pipeline.push(1);
        pipeline.push(2);
        pipeline.done();
    }

    function destination(data, pipeline) {
        items.push(data);
        pipeline.done();
    }

    const bundle = new Bundle();
    bundle.use({source});
    bundle.use({destination});

    bundle.setThrottle(100);
    bundle.start();

    t.plan(9);

    t.is(items.length, 0, 'no items to start with');

    let iterations = 0;

    bundle.on('end', () => {
        if (iterations === 0) {
            t.is(items.length, 2, 'received 2 items in total after the first iteration');
            t.is(items[0], 1, 'first item was correct');
            t.is(items[1], 2, 'second item was correct');
        }

        if (iterations === 1) {
            t.is(items.length, 4, 'received 4 items after the second iteration');
            t.is(items[0], 1, 'first item was correct');
            t.is(items[1], 2, 'second item was correct');
            t.is(items[2], 1, 'third item was correct');
            t.is(items[3], 2, 'fourth item was correct');

            bundle.stop();
            t.end();
        }

        iterations++;
    });
});

test.cb('loop and computeConfig', (t) => {
    const items = [];
    function source(pipeline) {
        pipeline.push(1);
        pipeline.push(2);
        pipeline.done();
    }

    function destination(data, pipeline) {
        items.push(data);
        pipeline.done();
    }

    const bundle = new Bundle();

    const initialConfig = {
        keepMe: 'please',
        incrementMe: -1 //this will increment before each run of the pipeline
    };

    bundle.computeConfig = (initialConfig, currentConfig) => {
        return Object.assign({}, initialConfig, {
            incrementMe: currentConfig.incrementMe + 1
        });
    };

    bundle.use({source});
    bundle.use({destination});

    bundle.setThrottle(100);

    t.plan(6);

    let iteration = -1;

    bundle.on('configComputed', (config) => {
        iteration++;
        t.is(config.keepMe, initialConfig.keepMe);
        t.is(config.incrementMe, iteration);
    });

    bundle.on('end', () => {
        if (iteration === 2) {
            bundle.stop();
            t.end();
        }
    });

    bundle.load(initialConfig).then(() => {
        bundle.start();
    });
});

test.cb('source that never calls `pipeline.done`', (t) => {
    const items = [];
    let iv;
    function source(pipeline) {
        let count = 0;

        clearInterval(iv);

        iv = setInterval(() => {
            pipeline.push(count += 1);
        }, 200);
    }

    function destination(data, pipeline) {
        items.push(data);
        pipeline.done();
    }

    const bundle = new Bundle();
    bundle.use({source});
    bundle.use({destination});

    bundle.start();

    t.plan(5);

    t.is(items.length, 0, 'no items to start with');

    setTimeout(() => {
        bundle.stop();
    }, 750);

    bundle.on('stopRequested', () => {
        t.is(items.length, 3, 'received 3 items in total');
        t.is(items[0], 1, 'first item was correct');
        t.is(items[1], 2, 'second item was correct');
        t.is(items[2], 3, 'third item was correct');

        clearInterval(iv);
        t.end();
    });
});

test.cb('using `take` with a source that never calls `pipeline.done`', (t) => {
    const items = [];
    let iv;
    function source(pipeline) {
        let count = 0;
        clearInterval(iv);
        iv = setInterval(() => {
            pipeline.push(count += 1);
        }, 200);
    }

    function destination(data, pipeline) {
        items.push(data);
        pipeline.done();
    }

    const bundle = new Bundle();
    bundle.use({source});
    bundle.use({destination});

    bundle.take(2);
    bundle.start();

    t.plan(4);

    t.is(items.length, 0, 'no items to start with');

    setTimeout(() => {
        bundle.stop();
    }, 650);

    bundle.on('stopRequested', () => {
        // we limited the bundle to 2 items so there should only be 2 here
        t.is(items.length, 2, 'received 2 items in total');
        t.is(items[0], 1, 'first item was correct');
        t.is(items[1], 2, 'second item was correct');

        clearInterval(iv);
        t.end();
    });
});

test.cb('using `take` together with `setThrottle` with a source that never calls `pipeline.done`', (t) => {
    const items = [];

    function source(pipeline) {
        pipeline.push({value: 1});
        pipeline.push({value: 2});
        pipeline.push({value: 3});
        pipeline.push({value: 4});
        pipeline.push({value: 5});
    }

    function destination(data, pipeline) {
        items.push(data);
        pipeline.done();
    }

    const bundle = new Bundle();
    bundle.use({source});
    bundle.use({destination});

    bundle.take(2);
    bundle.setThrottle(1000);

    bundle.start();

    t.plan(5);

    setTimeout(() => {
        bundle.stop();
    }, 1100);

    bundle.on('stopRequested', () => {
        t.is(items.length, 4, 'received 4 items in total');
        t.is(items[0].value, 1, 'first item was correct');
        t.is(items[1].value, 2, 'second item was correct');
        t.is(items[2].value, 1, 'first item was correct');
        t.is(items[3].value, 2, 'second item was correct');

        t.end();
    });
});

test.cb('source that errors', (t) => {
    const items = [];
    let iv;
    function source(pipeline) {
        let count = 0;
        clearInterval(iv);
        iv = setInterval(() => {
            if (count === 3) {
                pipeline.done(new Error('your source asplode'));
            } else {
                pipeline.push({value: count += 1});
            }
        }, 200);
    }

    function destination(data, pipeline) {
        items.push(data);
        pipeline.done();
    }

    const bundle = new Bundle();
    bundle.use({source});
    bundle.use({destination});

    bundle.on('error', (e) => {
        t.truthy(e, 'received an error');
        t.is(e.message, 'your source asplode', 'the emitted error was as expected');

        t.is(items.length, 3, 'received 3 items in total');
        t.is(items[0].value, 1, 'first item was correct');
        t.is(items[1].value, 2, 'second item was correct');
        t.is(items[2].value, 3, 'third item was correct');

        clearInterval(iv);
        t.end();
    });

    t.plan(7);

    bundle.start();
    t.is(items.length, 0, 'no items to start with');
});

test.cb('destination that buffers', (t) => {
    const items = [];
    let iv;
    function source(pipeline) {
        let count = 0;
        clearInterval(iv);
        iv = setInterval(() => {
            pipeline.push({value: count += 1});
            if (count === 2) {
                clearInterval(iv);
                pipeline.done();
            }
        }, 200);
    }

    function destination(data, pipeline) {
        items.push(data);
        pipeline.done();
    }

    const bundle = new Bundle();
    bundle.use({source});
    bundle.use({
        destination,
        buffered: true
    });
    bundle.setThrottle(600);

    t.plan(4);

    t.is(items.length, 0, 'no items to start with');

    bundle.on('end', () => {
        t.is(items.length, 1, 'received data once in total after 500ms');
        t.is(items[0][0].value, 1, 'first item value was correct');
        t.is(items[0][1].value, 2, 'second item value was correct');

        clearInterval(iv);
        bundle.stop();
        t.end();
    });

    bundle.load({}).then(() => {
        bundle.start();
    });
});

test.cb('destination that buffers error handling', (t) => {
    const items = [];
    let iv;
    function source(pipeline) {
        let count = 0;
        clearInterval(iv);
        iv = setInterval(() => {
            pipeline.push({value: count += 1});
            if (count === 2) {
                clearInterval(iv);
                pipeline.done(new Error('what the hell'));
            }
        }, 200);
    }

    function destination(data, pipeline) {
        items.push(data);
        pipeline.done();
    }

    const bundle = new Bundle();
    bundle.use({source});
    bundle.use({
        destination,
        buffered: true
    });

    bundle.on('error', (e) => {
        t.truthy(e, 'received an error');
        t.is(e.message, 'what the hell', 'the emitted error was as expected');
    });

    bundle.start();

    t.is(items.length, 0, 'no items to start with');

    setTimeout(() => {
        t.is(items.length, 0, 'received 0 items in total after 250ms');
    }, 250);

    setTimeout(() => {
        t.is(items.length, 1, 'received data once in total after 500ms');
        t.is(items[0][0].value, 1, 'first item value was correct');
        t.is(items[0][1].value, 2, 'second item value was correct');
    }, 700);

    setTimeout(() => {
        clearInterval(iv);
        bundle.stop();
        t.end();
    }, 1000);
});

test.cb('errors', (t) => {
    function source(pipeline) {
        pipeline.push(1);
        pipeline.push(2);
        pipeline.done();
    }

    function erroringTransform(data, pipeline) {
        pipeline.error(new Error('oh no!'));
    }

    function destination(data, pipeline) {
        pipeline.done();
    }

    const bundleConfig = {foo: 'bar'};

    const bundle = new Bundle();
    bundle.use({source});
    bundle.use({transform: erroringTransform});
    bundle.use({destination});

    bundle.on('error', (err, config) => {
        t.is(err.message, 'oh no!', 'passed the correct error to the error handler');
        t.deepEqual(config, bundleConfig, 'passed the bundle config to the error handler');

        t.end();
    });

    t.plan(2);

    bundle.load(bundleConfig).then(() => {
        bundle.start();
    });
});
