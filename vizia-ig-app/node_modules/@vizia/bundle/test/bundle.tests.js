'use strict';

const test = require('ava');
const sinon = require('sinon');

const EventEmitter = require('events');
const Bundle = require('../lib/Bundle');

test.cb('construction', t => {
    const bundle = new Bundle();

    t.truthy(bundle instanceof EventEmitter, 'it is an event emitter');
    t.is(bundle.limit, -1, 'bundle.limit === -1');
    t.is(bundle._hwm, 1, 'bundle._hwm === 1');

    t.end();
});

test.cb('bundle.setThrottle', t => {
    const bundle = new Bundle();

    bundle.setThrottle(1000);

    t.is(bundle.getThrottle(), 1000, 'returns set sleepInterval');

    t.end();
});

test.cb('bundle.getThrottle', t => {
    const bundle = new Bundle();
    const sleepInterval = bundle.getThrottle();

    t.is(sleepInterval, -1, 'returns default sleepInterval');

    t.end();
});

test.cb('bundle.use', t => {
    const bundle = new Bundle();

    const source = {source: () => {}};
    const transform1 = {transform: function transform1() {}};
    const tap = {tap: function tap() {}};
    const transform2 = {transform: function transform2() {}};
    const destination = {destination: function dest() {}};

    bundle.use(source);
    bundle.use(transform1);
    bundle.use(tap);
    bundle.use(transform2);
    bundle.use(destination);

    t.is(bundle.sourceSpec, source, 'can set the source');
    t.is(bundle.fnSpecs.length, 3, 'adds taps and transforms to bundle.fnSpecs');
    t.is(bundle.fnSpecs[0], transform1, 'added first transform to bundle.fnSpecs[0]');
    t.is(bundle.fnSpecs[1], tap, 'added first tap to bundle.fnSpecs[1]');
    t.is(bundle.fnSpecs[2], transform2, 'added second transform to bundle.fnSpecs[2]');
    t.is(bundle.destinationSpec, destination, 'can set the destination');

    t.end();
});

test.cb('bundle.load', t => {
    t.plan(2);

    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};

    bundle.on('load', (opts) => {
        t.pass('emits a start event');
        t.deepEqual(opts.config, bundleConfig, 'passes the config to the load handler');

        t.end();
    });

    bundle.load(bundleConfig);
});

test('bundle.load freezes config', t => {
    t.plan(1);

    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};

    return bundle.load(bundleConfig).then(() => {
        const config = bundle.initialConfig;

        config.foo = 'baz';
    }).catch(err => {
        t.is(err.message, 'Cannot assign to read only property \'foo\' of object \'#<Object>\'');
    });
});

test.cb('bundle.preconfig returning a Promise', t => {
    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};

    bundle.preconfig = () => {
        return new Promise((resolve) => {
            setTimeout(() => resolve({
                bar: 'something-added-asynchronously'
            }), 0);
        });
    };

    bundle.load(bundleConfig);

    bundle.on('load', opts => {
        const {config} = opts;

        t.is(config.foo, 'bar', 'has the config passed into load');
        t.is(config.bar, 'something-added-asynchronously', 'has the config from preconfig');

        t.end();
    });
});

test.cb('bundle.preconfig returning an object', t => {
    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};

    bundle.preconfig = () => {
        return {
            bar: 'something-added-synchronously'
        };
    };

    bundle.load(bundleConfig);

    bundle.on('load', opts => {
        const {config} = opts;

        t.is(config.foo, 'bar', 'has the config passed into load');
        t.is(config.bar, 'something-added-synchronously', 'has the config from preconfig');

        t.end();
    });
});

test.cb('bundle.preconfig throwing', t => {
    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};
    const expectedError = new Error('bang! A synchronously thrown error');

    bundle.preconfig = () => {
        throw expectedError;
    };

    bundle.on('error', err => {
        t.is(err.message, expectedError.message);
        t.end();
    });

    bundle.load(bundleConfig);
});

test.cb('bundle.preconfig rejecting', t => {
    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};
    const expectedError = new Error('bang! An asynchronously thrown error');

    bundle.preconfig = () => Promise.reject(expectedError);

    bundle.on('error', err => {
        t.is(err.message, expectedError.message);
        t.end();
    });

    bundle.load(bundleConfig);
});

test.cb('bundle.computeConfig returning a Promise', t => {
    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};

    sinon.stub(bundle, '_startPipeline');

    bundle.computeConfig = () => {
        return new Promise((resolve) => {
            setTimeout(() => resolve(Object.assign(bundleConfig, {
                bar: 'something-added-asynchronously'
            })), 0);
        });
    };

    t.plan(4);

    bundle.on('load', opts => {
        const {config} = opts;

        t.is(config.foo, 'bar', 'has the config passed into load');
        t.is(config.bar, undefined, 'does not have the config from preconfig');
    });

    bundle.on('configComputed', config => {
        t.is(config.foo, 'bar', 'has the config passed into load');
        t.is(config.bar, 'something-added-asynchronously', 'has the config from computeConfig');

        t.end();
    });

    bundle.load(bundleConfig).then(() => bundle.start());
});

test.cb('bundle.computeConfig returning an Object', t => {
    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};

    sinon.stub(bundle, '_startPipeline');

    bundle.computeConfig = () => {
        return Object.assign(bundleConfig, {
            bar: 'something-added-synchronously'
        });
    };

    t.plan(4);

    bundle.on('load', opts => {
        const {config} = opts;

        t.is(config.foo, 'bar', 'has the config passed into load');
        t.is(config.bar, undefined, 'does not have the config from preconfig');
    });

    bundle.on('configComputed', config => {
        t.is(config.foo, 'bar', 'has the config passed into load');
        t.is(config.bar, 'something-added-synchronously', 'has the config from computeConfig');

        t.end();
    });

    bundle.load(bundleConfig).then(() => bundle.start());
});

test.cb('bundle.computeConfig throwing', t => {
    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};
    const expectedError = new Error('bang! A synchronously thrown error');

    bundle.computeConfig = () => {
        throw expectedError;
    };

    bundle.on('error', err => {
        t.is(err.message, expectedError.message);
        t.end();
    });

    bundle.load(bundleConfig).then(() => bundle.start());
});

test.cb('bundle.computeConfig rejecting', t => {
    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};
    const expectedError = new Error('bang! An asynchronously thrown error');

    bundle.computeConfig = () => Promise.reject(expectedError);

    bundle.on('error', err => {
        t.is(err.message, expectedError.message);
        t.end();
    });

    bundle.load(bundleConfig).then(() => bundle.start());
});

test('bundle.start', t => {
    t.plan(4);

    const source = {
        source: (pipeline) => {
            pipeline.push({value: 1});
            pipeline.done();
        }
    };

    const destination = {
        destination: (data, pipeline) => {
            pipeline.done();
        }
    };

    const bundle = new Bundle();
    const bundleConfig = {foo: 'bar'};
    const executePipelineStub = sinon.stub(bundle, 'executePipeline');

    bundle.use(source);
    bundle.use(destination);

    bundle.on('start', (opts) => {
        t.pass('emits a start event');
        t.deepEqual(opts.config, bundleConfig, 'passes the config to the start handler');
    });

    return bundle.load(bundleConfig).then(() => {
        bundle.start();

        t.is(bundle.stopRequested, false, 'sets bundle.stopRequested to false');
        t.is(executePipelineStub.callCount, 1, 'executes the pipeline');
    });
});

test.cb('bundle.take', t => {
    const bundle = new Bundle();
    bundle.take(5);

    t.is(bundle.limit, 5, 'sets bundle.limit');
    t.end();
});

test.cb('bundle.loop', t => {
    const clock = sinon.useFakeTimers();
    const bundle = new Bundle();
    const executePipelineStub = sinon.stub(bundle, 'executePipeline');
    const fakeConfig = {foo: 'bar'};

    bundle.config = fakeConfig;
    bundle.setThrottle(-1);

    const getThrottleSpy = sinon.spy(bundle, 'getThrottle');

    bundle.loop(fakeConfig);
    clock.tick(1000);

    t.is(getThrottleSpy.callCount, 1, 'executes getThrottle');
    t.deepEqual(getThrottleSpy.getCall(0).args[0], fakeConfig,
        'executes getThrottle with the pipeline config');

    t.is(executePipelineStub.callCount, 0, 'does not execute pipeline if setThrottle < 0');

    bundle.setThrottle(1000);
    bundle.loop(fakeConfig);
    clock.tick(999);
    t.is(executePipelineStub.callCount, 0,
        'does not execute pipeline before setThrottle ms elapses');
    clock.tick(1);
    t.is(executePipelineStub.callCount, 1,
        'executes the pipeline after setThrottle ms elapses');

    bundle.stopRequested = true;
    bundle.loop(fakeConfig);
    clock.tick(1000);
    t.is(executePipelineStub.callCount, 1,
        'does not execute pipeline if bundle.stopRequested ==== true');

    clock.restore();
    t.end();
});

test.cb('bundle.getPipelineArray', t => {
    const bundle = new Bundle();

    const makeTransformStreamSpy = sinon.spy(bundle, '_makeTransformStream');
    const makeTapStreamSpy = sinon.spy(bundle, '_makeTapStream');
    const makeSourceStreamSpy = sinon.spy(bundle, '_makeSourceStream');

    const source = {source: () => {}};
    const transform1 = {transform: function transform1() {}};
    const tap = {tap: function tap() {}};
    const transform2 = {transform: function transform2() {}};
    const destination = {destination: function dest() {}};

    bundle.use(source);
    bundle.use(transform1);
    bundle.use(tap);
    bundle.use(transform2);
    bundle.use(destination);

    const pipeline = bundle.getPipelineArray();

    t.is(makeSourceStreamSpy.callCount, 1, 'called _makeSourceStream once');
    t.is(makeTransformStreamSpy.callCount, 2, 'called _makeTransformStream twice');
    t.is(makeTapStreamSpy.callCount, 1, 'called _makeTapStream once');

    t.is(pipeline.length, 4, 'pipeline contains four items');

    t.is(pipeline[0], makeSourceStreamSpy.returnValues[0], 'first pipeline item is the source');
    t.is(pipeline[1], makeTransformStreamSpy.returnValues[0], 'second pipeline item is the first transform');
    t.is(pipeline[2], makeTapStreamSpy.returnValues[0], 'third pipeline item is the tap');
    t.is(pipeline[3], makeTransformStreamSpy.returnValues[1], 'fourth pipeline item is the second transform');

    t.end();
});

test.cb('source error with a proper error instance', t => {
    const bundle = new Bundle();
    const errorInstance = new Error('boom');
    bundle.use({
        source: (pipeline) => {
            pipeline.error(errorInstance);
        }
    });

    bundle.use({
        destination: () => {}
    });

    t.plan(1);

    bundle.on('error', e => {
        t.is(e, errorInstance);
    });

    bundle.on('end', () => t.end());

    bundle.start();
});

test.cb('source error with a string', t => {
    const bundle = new Bundle();
    const error = 'boom';
    bundle.use({
        source: (pipeline) => {
            pipeline.error(error);
        }
    });

    bundle.use({
        destination: () => {}
    });

    t.plan(1);

    bundle.on('error', e => {
        t.is(e.message, error);
    });

    bundle.on('end', () => t.end());

    bundle.start();
});

test.cb('transform error with a proper error instance', t => {
    const bundle = new Bundle();
    const errorInstance = new Error('boom');
    bundle.use({
        source: (pipeline) => {
            pipeline.push({value: 1});
            pipeline.done();
        }
    });

    bundle.use({
        transform: (data, pipeline) => {
            return pipeline.error(errorInstance);
        }
    });

    bundle.use({
        destination: () => {}
    });

    t.plan(1);

    bundle.on('error', e => {
        t.is(e, errorInstance);
    });

    bundle.on('end', () => t.end());

    bundle.start();
});

test.cb('transform error with a string', t => {
    const bundle = new Bundle();
    const error = 'boom';
    bundle.use({
        source: (pipeline) => {
            pipeline.push({value: 1});
            pipeline.done();
        }
    });

    bundle.use({
        transform: (data, pipeline) => {
            return pipeline.error(error);
        }
    });

    bundle.use({
        destination: () => {}
    });

    t.plan(1);

    bundle.on('error', e => {
        t.is(e.message, error);
    });

    bundle.on('end', () => t.end());

    bundle.start();
});
