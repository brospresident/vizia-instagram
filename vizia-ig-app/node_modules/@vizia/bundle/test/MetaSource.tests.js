'use strict';

const test = require('ava');
const Bundle = require('../lib/Bundle');
const metaSource = require('../lib/MetaSource');

function source(seed, times = 1) {
    let val = seed;

    return {
        source: (pipeline) => {
            for (let i = 0; i < times; i++) {
                pipeline.push({value: val});
                val += 2;
            }

            pipeline.done();
        }
    };
}

function transform() {
    return {
        transform: (data, pipeline) => {
            setTimeout(() => {
                pipeline.push(data);
                pipeline.done();
            }, Math.random() * 100);
        }
    };
}

function erroringTransform(err) {
    return {
        transform: (data, pipeline) => {
            return pipeline.error(err);
        }
    };
}

function evenBundle() {
    const bundle = new Bundle();
    bundle.use(source(0, 5)); // 0, 2, 4, 6, 8
    bundle.use(transform());

    return bundle;
}

function oddBundle() {
    const bundle = new Bundle();
    bundle.use(source(1, 2)); // 1, 3
    bundle.use(transform());

    return bundle;
}

test.cb('pipeline', t => {
    const evenInstance = evenBundle();
    const oddInstance = oddBundle();
    const source = metaSource(evenInstance, oddInstance);
    const bundle = new Bundle();
    const fakeConfig = {foo: 'bar'};
    const evenInstanceExpected = [
        {value: 0},
        {value: 2},
        {value: 4},
        {value: 6},
        {value: 8}
    ];
    const oddInstanceExpected = [
        {value: 1},
        {value: 3}
    ];

    t.plan(4);

    bundle.use({source});

    bundle.use({
        tap: (data, pipeline) => {
            t.deepEqual(data[0], evenInstanceExpected);
            t.deepEqual(data[1], oddInstanceExpected);
            t.deepEqual(pipeline.config, fakeConfig);
        }
    });

    bundle.use({
        destination: data => {
            t.deepEqual(data, [evenInstanceExpected, oddInstanceExpected]);
            t.end();
        }
    });

    bundle.load(fakeConfig).then(() => bundle.start());
});

test.cb('error', t => {
    const evenInstance = evenBundle();
    const oddInstance = oddBundle();

    const expectedError = new Error('burninated');
    oddInstance.use(erroringTransform(expectedError));

    const source = metaSource(evenInstance, oddInstance);

    const bundle = new Bundle();

    t.plan(1);

    bundle.use({source});
    bundle.use({destination: () => t.fail('should not be hit')});

    bundle.on('data', () => {
        t.fail('should not be called');
    });

    bundle.on('error', e => {
        t.is(e, expectedError);
        t.end();
    });

    bundle.start();
});

test.cb('iterations', t => {
    const evenInstance = evenBundle();
    const oddInstance = oddBundle();
    const source = metaSource(evenInstance, oddInstance);
    const bundle = new Bundle();
    const fakeConfig = {foo: 'bar'};
    const evenInstanceExpecteds = [
        [
            {value: 0},
            {value: 2},
            {value: 4},
            {value: 6},
            {value: 8}
        ],
        [
            {value: 10},
            {value: 12},
            {value: 14},
            {value: 16},
            {value: 18}
        ]
    ];
    const oddInstanceExpecteds = [
        [
            {value: 1},
            {value: 3}
        ],
        [
            {value: 5},
            {value: 7}
        ]
    ];

    let iterationIdx = 0;

    t.plan(8);

    bundle.use({source});

    bundle.use({
        tap: (data, pipeline) => {
            t.deepEqual(data[0], evenInstanceExpecteds[iterationIdx]);
            t.deepEqual(data[1], oddInstanceExpecteds[iterationIdx]);
            t.deepEqual(pipeline.config, fakeConfig);

            iterationIdx++;
        }
    });

    bundle.use({
        destination: (data, pipeline) => {
            if (iterationIdx === 1) {
                t.deepEqual(data, [evenInstanceExpecteds[0], oddInstanceExpecteds[0]]);
            }

            if (iterationIdx === 2) {
                t.deepEqual(data, [evenInstanceExpecteds[1], oddInstanceExpecteds[1]]);
                bundle.stop();
                return t.end();
            }

            pipeline.done();
        }
    });

    bundle.setThrottle(100);

    bundle.load(fakeConfig).then(() => bundle.start());
});
