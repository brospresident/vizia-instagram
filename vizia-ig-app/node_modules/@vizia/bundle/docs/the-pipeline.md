# The Pipeline

The fundamental design principle of `Bundle` is that data should travel from the `Source` and end up at the `Destination`, optionally passing through `Transform` modules on the way.

Under the hood, `Bundle` uses NodeJS streams to create a pipeline and manage the data flows. It is not
necessary to have an understanding of streams in order to use the library, as it abstracts over the implementation. In fact, the abstraction presented to the developer is more akin to [Express.Js](http://expressjs.com/), where a `.use` method is provided to instruct `Bundle` to add a module
to the Pipeline.

We use named properties on the object supplied to the `.use` method to indicate that a module is to be used as either a `source`, `transform`, `destination` or `tap`. The [simple, contrived, example code](simple-contrived.md) in this documentation illustrates this usage.

## The Pipeline Lifecycle

When Vizia calls `bundle.start()`, a new Pipeline is constructed. It will immediately call the `source`, and allow data to progress down to the `destination`. The lifetime of the pipeline is governed both by `done()` and `error()` arguments, which are passed on the `pipeline` property to each `source`, `transform` and `destination`.

A pipeline will close down in any of the following circumstances:

1. Every module registered by `bundle.use()` has called `pipeline.close()`
2. Any single module has called `pipeline.error()` with an instance of an error.
3. The `destination` received `n` items, as specified by `bundle.take(n)`

Once a pipeline is closed, the app will do nothing more, unless `bundle.setThrottle(ms)` has been called.
In this scenario, the app will wait for `ms` milliseconds before constructing a brand new pipeline and executing that.

This allows for great flexibility. For example, a `source` that can continuously emit data need never call
`pipeline.done`, and allow for an app to consume its data indefinitely (assuming it does not close due to a
`pipeline.error` call), or indeed to choose to only consume `n` of its data items due to `bundle.take(n)` being called.

Conversely, it's possible to make an app that only runs once by not setting `bundle.setThrottle`.

Alternatively, an author has the ability to override the `getThrottle` method in order to set the throttle dynamically, based on the loaded pipeline config. For example, when a Vizia admin has chosen to show either historical or real-time data, the interval can be optimised based on the context.

The power is in the hands of the developer configuring his/her app, rather than the author of individual modules.
