# Build your first app

In addition to all of the modules available
as part of the Vizia for Developers ecosystem, we have made
available a tool that helps you scaffold your first app. That tool is
`Mr Bundle`.

## Installing Mr. Bundle

Mr Bundle is available in `npme`. To install:

`$ npm install -g @vizia/mr-bundle`

Mr Bundle is then ready to use. Let's scaffold our first app:

1. First create a new working directory for your app, eg `$ mkdir my-first-app`
2. Now enter that directory `$ cd my-first-app`
3. Now run Mr Bundle: `$ mrbundle create bundle`
4. Follow the prompts to enter the metadata about your app:
   * `Package name` is the name of your app
   * `Title` is the human-readable name of your app
   * `Scope` should be the name of your npme scope (eg your company name)
   * `Version` is the version number
   * `Description` is a human-friendly description of your app's functionality
5. Once you've entered the metadata, wait a few seconds for Mr Bundle to work its magic.

Let's now explore what Mr Bundle has created.

### Structure of an Mr Bundle app

 Mr Bundle takes away the effort of making a lot of boilerplate:

 1. Creates `package.json`
 2. Creates dotfiles
 3. Creates a demo environment
 4. Adds a thin app structure

Next, let's examine each of these in turn.

#### 1. package.json

 A `package.json` file is created, and bootstrapped with dependencies and dev
 scripts that get you up and running as quickly as possible.

 The following scripts are generated:

  * `npm start` - builds your app with browserify and serves it locally
  * `npm test` - runs the unit tests (an example test is provided)
  * `npm run lint` - runs eslint
  * `npm run build` - packages up your app with browserify


   The following notable dependencies are added:

  * `@vizia/bundle` - the framework
  * `ava` - test runner
  * `browserify` - build tooling

It is recommended that you use the Browserify builds as configured by Mr. Bundle.


#### 2. dotFiles

Mr Bundle adds various dotfiles to your project:

 * `.editorconfig` - settings for the excellent [IDE Extension](http://editorconfig.org/)
 * `.nvmrc` - setting for [Node Version Manager](https://github.com/creationix/nvm)
 * `.eslintrc` - settings for [The ESLint linter](https://eslint.org/)

Feel free to override these with your own preferences!


#### 3. The demo environment

Mr Bundle creates a folder called `demo` in the root of your project, containing the following

 * `index.html` - This is some basic HTML that your code will load into. It simulates Vizia's DOM
 and CSS, so you can see what your app will look like as a Vizia tile. It is _strongly_ recommended that
you do not touch this file.
 * `demo.js` - This contains some JavaScript that simulates Vizia loading your app as a tile. The
 most important thing to note here is the `bundle.load` line, which simulates the injection of
 user-land config from Vizia admin into your app. You are encouraged to test your app by editing
 the value of the `scene.options` property of the object passed to `bundle.load`, adding in the
 parameters that your app expects from Vizia admin

The demo environment is executed by `$ npm start` which will start a dev server, the location of which will
be printed to the terminal.

#### 4. The app itself

Mr Bundle provides a simple structure for your app, all contained in the `src` directory of your
project.

* `index.js` - the main entry point for your app.
* `browser.js` - the place all your DOM-related code should go
* `lib/create-bundle.js` - where you initialise your app and wire up the `Sources`, `Transforms` and `Destination`

Note that Mr. Bundle creates a fully-working Clock app for you, so you can go ahead and `npm start` to see it running.

Let's now examine the Clock app that Mr Bundle has built, by taking a closer look at the above three files.

##### lib/create-bundle.js

This is the most complex file in the demo app, as it is where the majority of work takes place.

```JavaScript
const Bundle = require('@vizia/bundle');
```

The above line requires in the framework itself.

```JavaScript
function createSource() {
    return {
        source(pipeline) {
            pipeline.push({
                date: new Date().toISOString()
            });
            pipeline.done();
        }
    };
}
```

Next, we define a factory function that creates a `Source`. In production-ready projects,
this factory function would exist in a separate file, to facilitate unit testing.

```JavaScript
function createBundle(createDestination) {
    const bundle = new Bundle();

    // TODO: Set up your source, transforms and destination here
    bundle.setThrottle(1000);
    bundle.use(createSource());
    bundle.use(createDestination());

    return bundle;
}
```

Here is where the plumbing of the implementation exists. First we `new` up an instance of
the `Bundle`, then we start creating the code pipeline by adding the `Source` and `Destination`.

We also invoke `bundle.setThrottle`, passing in a value of 1000ms. This instructs the framework to
wait 1000ms from when the destination finishes processing the data before executing again.

```JavaScript
module.exports = createBundle;
```

Finally, we export the `createBundle` function.


##### browser.js

This is where we set up DOM-based operations. In 99% of use-cases, the only place that an app should have knowledge
of the DOM is in the `Destination`, and this example Clock app adheres to that principle. We see a simple `Destination`
factory function, `createDestination`, which returns a `Destination` specification, and the only other code in the file
is a line which takes this function and passes it as an argument to the export of the `lib/create-bundle.js` file.

##### index.js

This is a very simple file, that currently just exports `browser.js`. It is recommended that you leave this untouched
as it exists for future backward-compatability with server-side execution of apps.
