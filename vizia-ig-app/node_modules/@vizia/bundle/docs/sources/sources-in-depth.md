# Sources In Depth

This document demonstrates different ways to create `Source` modules.

## What is a Source?

A `Source` is a module that emits data. The data can take any form - it could
be a simple primitive such as a number, a JavaScript Object, or an Array.

Sources can operate in one of two modes - they can emit data forever, or emit one or more pieces of data before they signal that they have finished.

A source is expressed in JavaScript as an object with a property named source, which is a function taking a single argument, `pipeline`:

```js
{
    source: (pipeline) => {
        //implementation
    }
}
```

The pipeline argument, supplied by Vizia at runtime, is an object with various properties:

| Name  | Type | Description |
|---|---|---|
| config | Object  | An object containing the runtime config, from Vizia admin  |
| push  | Function   | A function with a single argument, `data`, used to send data on to the next module in the App's pipeline  |
| done  | Function  | A function with no arguments, used to signal that the source is done sending data, and will not send more in this iteration of the pipeline  |
| error  | Function  | A function with a single argument, `error`, that signals an error occurrence that cannot be recovered from. |

The key properties of note are `pipeline.push(data)` and `pipeline.done()`. By using these in different ways we can create sources that stream data endlessly, push a lot of data at once, and optionally signal that they've finished.

Let's look at some simple, contrived, examples. Let's imagine a use-case where
we need to generate random numbers. We can create sources that behave differently:

In this first example, we create a source that will emit a single random number, and then close.

```js
{
    source: (pipeline) => {
        pipeline.push(Math.random());
        pipeline.done();
    }
}
```

In this second example, we create a source that endlessly emits numbers:

```js
{
    source: (pipeline) => {
        const interval = setInterval(() => {
            pipeline.push(Math.random());
        }, 0);
    }
}
```

Note that in this second example, `pipeline.done()` is never called, so the source will never close down.

In this third example, we emit `n` numbers, as specified by the `pipeline.config.amount` property

```js
{
    source: (pipeline) => {
        const {amount} = pipeline.config;

        for(let i=0; i<amount; i++)
            pipeline.push(Math.random());
        }

        pipeline.done();
    }
}
```

We could also emit an array:

```js
{
    source: (pipeline) => {
        const {amount} = pipeline.config;
        const numbers = [];

        for(let i=0; i<amount; i++)
            numbers.push(Math.random());
        }

        pipeline.push(numbers);
        pipeline.done();
    }
}
```

Finally, and importantly, we can call `pipeline.push()` and `pipeline.done()` asynchronously. Let's use a more typical use-case here,
where we need to do an HTTP request to a remote server for some data.

```js
{
    source: (pipeline) => {
        fetch('http://example.com/movies.json').then(function(response) {
            return response.json();
        }).then(function(jsonData) {
            pipeline.push(jsonData);
            pipeline.done();
        });
    }
}
```

## Best Practices when building a sources

### 1. Avoid polling

It is generally best practice to design a source to emit data once, and leave the implementation (or not) to the App developer. For example, if your
source collects data from a HTTP API, the App developer may only need the data once, infrequently, or very frequently. He/She can build an app that uses `bundle.throttle(n)` to govern the polling, or emit this line entirely for an app that calls the source once. If you implement your own polling mechanism in your source, the app developer will not have this control

### 2. Collecting data from multiple api endpoints

If you need to collect data from multiple API calls and collate it, consider
using `Promise.all`:

```js
function fetchMovies(){
    return fetch('http://example.com/movies.json').then(function(response) {
        return response.json();
    });
}

function fetchBooks(){
    return fetch('http://example.com/books.json').then(function(response) {
        return response.json();
    });
}

module.exports = {
    source: (pipeline) => {
        Promise.all([
            fetchMovies(),
            fetchBooks()
        ]).then((movies, books) => {
            pipeline.push({
                books,
                movies
            });
            pipeline.done();
        })
    }
}
```
