'use strict';

const EventEmitter = require('events');
const concat = require('concat-stream');

module.exports = class MetaBundle extends EventEmitter {
    constructor(...bundles) {
        super();

        this.bundles = [...bundles].map(b => {
            b.sleepInterval = -1; //override looping

            b.getDestination = () => concat(data => { //always concat all the data
                b.emit('data', data);
                b.emit('end');
            });

            return b;
        });
    }

    setThrottle(ms) {
        this.sleepInterval = ms;
    }

    load(config) {
        return Promise.all(this.bundles.map(b => b.load(config)));
    }

    start() {
        this.stopRequested = false;
        this.emit('start', {config: this.config});

        const onEnd = () => {
            this.emit('end');
            this.loop();
        };

        this.execute().then(onEnd, onEnd);
    }

    execute() {
        if (this.stopRequested) {
            return console.warn('not executing due to `stop` request'); // eslint-disable-line no-console
        }

        this._errored = false;

        const endPromises = this.bundles.map(b => new Promise((resolve, reject) => {
            b.once('error', reject);
            b.once('end', err => setTimeout(() => err ? reject(err) : resolve()), 0);
        }));

        const dataPromises = this.bundles.map((b, idx) => new Promise(resolve => {
            b.once('data', data => setTimeout(() => resolve({idx, data}), 0));
        }));

        this.bundles.forEach(b => b.start());

        Promise.all(dataPromises).then(results => {
            if (!this._errored) {
                this.emit('data', results.reduce((memo, result) => {
                    memo[result.idx] = result.data;
                    return memo;
                }, []));
            }
        });

        return Promise.all(endPromises).catch(err => {
            this._errored = true;
            this.emit('error', err);
            this.emit('end');
        });
    }

    stop() {
        this.stopRequested = true;
        this.bundles.forEach(b => b.stop());
    }

    loop() {
        if (this.sleepInterval > -1 && !this.stopRequested) {
            console.log('queuing next pipeline execution', new Date()); // eslint-disable-line no-console
            setTimeout(this.execute.bind(this), this.sleepInterval);
        }
    }
};
