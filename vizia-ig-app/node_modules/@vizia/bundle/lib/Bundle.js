'use strict';

const EventEmitter = require('events');
const from = require('from2');
const through = require('through2');
const writer = require('to2');
const pumpify = require('pumpify');
const concat = require('concat-stream');
const spy = require('through2-spy');
const eos = require('end-of-stream');

function ensureError(err) {
    return err instanceof Error ? err : new Error(err.message || err);
}

module.exports = class Bundle extends EventEmitter {
    constructor() {
        super();
        this.initialConfig = {};
        this.fnSpecs = [];
        this.limit = -1;
        this._hwm = 1; // highWaterMark for streams. Don't mess with it unless you know what you're doing.
    }

    setThrottle(ms) {
        this.getThrottle = () => ms;
    }

    getThrottle() {
        return -1;
    }

    use(obj) {
        if (obj.source) {
            this.sourceSpec = obj;
        } else if (obj.transform || obj.tap) {
            this.fnSpecs.push(obj);
        } else if (obj.destination) {
            this.destinationSpec = obj;
        }
    }

    async preconfig(config) {
        return config;
    }

    async computeConfig(initialConfig, currentConfig) {
        return currentConfig;
    }

    async load(config) {
        let processedConfig;
        try {
            processedConfig = await this.preconfig(config);
        } catch (e) {
            return this.emit('error', e);
        }

        this.initialConfig = Object.freeze(Object.assign({}, config, processedConfig));
        this.emit('load', {config: this.initialConfig});
    }

    start() {
        this.stopRequested = false;
        this.emit('start', {config: this.initialConfig});
        this.executePipeline(this.initialConfig);
    }

    take(n) {
        this.limit = n;
    }

    stop() {
        this.emit('stopRequested', this);
        this.stopRequested = true;

        if (this.pipeline) {
            this.pipeline.destroy();
        }
    }

    loop(currentConfig) {
        const sleepInterval = this.getThrottle(currentConfig);
        if (Number.isFinite(sleepInterval) && sleepInterval >= 0 && !this.stopRequested) {
            console.log('queuing next pipeline execution', new Date()); // eslint-disable-line no-console
            setTimeout(this.executePipeline.bind(this, currentConfig), sleepInterval);
        }
    }

    getPipelineArray(config) {
        const transforms = this.fnSpecs.map((obj) => {
            if (obj.transform) {
                return this._makeTransformStream(obj, config);
            }
            return this._makeTapStream(obj, config);
        }, this);

        return [
            this._makeSourceStream(this.sourceSpec, config),
            ...transforms
        ];
    }

    getDestination(config) {
        if (this.destinationSpec.buffered) {
            return this._makeBufferedDestinationStream(this.destinationSpec, config);
        }
        return this._makeDestinationStream(this.destinationSpec, config, this.limit);
    }

    async executePipeline(currentConfig) {
        if (this.pipeline) {
            this.pipeline.destroy();
        }

        this._allowPush = true;

        if (this.stopRequested) {
            console.warn('not executing due to `stop` request'); // eslint-disable-line no-console
            return;
        }

        let processedConfig;
        try {
            processedConfig = await this.computeConfig(this.initialConfig, currentConfig);
        } catch (e) {
            return this.emit('error', e);
        }

        this.emit('configComputed', processedConfig);
        this._startPipeline(processedConfig);
    }

    _startPipeline(currentConfig) {
        this.pipeline = pumpify.obj();

        eos(this.pipeline, (err) => {
            this._allowPush = false;
            if (err) {
                this.emit('error', err, currentConfig);
            }
            this.emit('end', err);
            this.loop(currentConfig);
        });

        this.pipeline.setPipeline(...this.getPipelineArray(currentConfig), this.getDestination(currentConfig));
    }

    _makeSourceStream(spec, config) {
        const stream = from.obj({highWaterMark: this._hwm}, (size, next) => {
            const done = err => setTimeout(() => next(err ? ensureError(err) : null, null), 0)
            try {
                spec.source({
                    config,
                    push: data => this._safePush(stream, data),
                    error: done,
                    done
                });
            } catch (err) {
                next(err);
            }
        });

        return stream;
    }

    _makeTransformStream(spec, config) {
        const stream = through.obj({highWaterMark: this._hwm}, (chunk, enc, callback) => {
            try {
                spec.transform(chunk, {
                    config,
                    push: data => this._safePush(stream, data),
                    error: err => setTimeout(() => callback(ensureError(err)), 0),
                    done: () => setTimeout(() => callback(), 0)
                });
            } catch (err) {
                callback(err);
            }
        });

        return stream;
    }

    _makeTapStream(spec, config) {
        return spy.obj((data) => {
            spec.tap(data, {config});
        });
    }

    _makeBufferedDestinationStream(spec, config) {
        return concat((data) => {
            spec.destination(data, {
                config,
                done: () => {}
            });
        });
    }

    _makeDestinationStream(spec, config, limit) {
        let calls = 0;

        const ws = writer.obj({highWaterMark: this._hwm}, (data, enc, done) => {
            calls += 1;

            if (limit > 0 && calls > limit) {
                this._allowPush = false;
                ws.end();
                done(null);
                return;
            }

            this.emit('data', data);

            spec.destination(data, {
                config,
                done,
                error: done
            });
        });

        return ws;
    }

    // force the consumer's usage of pipeline.push to be async,
    // and also check we have not hit the limit imposed by this.take(n)
    // so we avoid writing to a stream that is closed/closing
    _safePush(stream, data) {
        setTimeout(() => this._allowPush && stream.push(data), 0);
    }
};
