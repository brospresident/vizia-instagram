'use strict';

/**
 * Parses number according to the provided locale, so that delimiters etc are interpreted properly
 */
const createParseNumber = (locale) => {
    const parts = new Intl.NumberFormat(locale).formatToParts(12345.6);
    const numerals = [
        ...new Intl.NumberFormat(locale, {useGrouping: false}).format(9876543210)
    ].reverse();
    const numeralIndexMap = new Map(numerals.map((numeral, i) => [numeral, i]));

    const groupTest = new RegExp(`[${parts.find(d => d.type === 'group').value}]`, 'g');
    const decimalTest = new RegExp(`[${parts.find(d => d.type === 'decimal').value}]`);
    const numeralTest = new RegExp(`[${numerals.join('')}]`, 'g');
    const otherTest = new RegExp('[^0-9-.]', 'g');

    return (value) => {
        // Sanitises to string parseable as JavaScript float
        const sanitized = value
            .trim()
            // Strip group seperator (delimiter)
            .replace(groupTest, '')
            // Replace locale decimal with standard decimal
            .replace(decimalTest, '.')
            // Replace locale numerals with standard numerals
            .replace(numeralTest, (numeral) => numeralIndexMap.get(numeral))
            // Finally, strip out all other characters
            .replace(otherTest, '');

        return parseFloat(sanitized) || NaN;
    };
};

/**
 * Parses value to numeric
 * If it's a string, it will attempt to extract the numeric value
 * Otherwise, it's NaN
 */
const parseValue = (value, {locale = 'en'} = {}) => {
    if (typeof value === 'string') {
        const parseNumber = createParseNumber(locale);
        return parseNumber(value);
    } else if (Number.isFinite(value)) {
        return value;
    }
    return NaN;
};

module.exports = parseValue;
