'use strict';

const test = require('ava');

const parseValue = require('../src/lib/parse-value');

require('../src/polyfill/intl');

test('Int', (t) => {
    t.is(parseValue(5000), 5000);
    t.is(parseValue(-5000), -5000);
});

test('Float', (t) => {
    t.is(parseValue(5000.5), 5000.5);
    t.is(parseValue(-5000.5), -5000.5);
});

test('String', (t) => {
    t.is(parseValue('5000'), 5000);
    t.is(parseValue('-5000'), -5000);
});

test('String: float', (t) => {
    t.is(parseValue('5000.5'), 5000.5);
    t.is(parseValue('-5000.5'), -5000.5);
});

test('String: float with delimiter', (t) => {
    t.is(parseValue('5,000.5'), 5000.5);
    t.is(parseValue('-5,000.5'), -5000.5);
});

test('String: float with delimiter and currency symbol', (t) => {
    t.is(parseValue('£5,000.5'), 5000.5);
    t.is(parseValue('-£5,000.5'), -5000.5);
    t.is(parseValue('£-5,000.5'), -5000.5);
});

test('String: float with delimiter and additional text', (t) => {
    t.is(parseValue('5,000.5 things'), 5000.5);
    t.is(parseValue('-5,000.5 things'), -5000.5);
    t.is(parseValue('5,000.5kg'), 5000.5);
    t.is(parseValue('-5,000.5kg'), -5000.5);
});

test('String: float with delimiter in Italian locale', (t) => {
    t.is(parseValue('5.000,5', {locale: 'it'}), 5000.5);
    t.is(parseValue('-5.000,5', {locale: 'it'}), -5000.5);
});

test('String: float with delimiter and currency symbol in Italian locale', (t) => {
    t.is(parseValue('£5.000,5', {locale: 'it'}), 5000.5);
    t.is(parseValue('-£5.000,5', {locale: 'it'}), -5000.5);
    t.is(parseValue('£-5.000,5', {locale: 'it'}), -5000.5);
});

test('String: float with delimiter and additional text in Italian locale', (t) => {
    t.is(parseValue('5.000,5 pizzas', {locale: 'it'}), 5000.5);
    t.is(parseValue('-5.000,5 pizzas', {locale: 'it'}), -5000.5);
    t.is(parseValue('5.000,5kg', {locale: 'it'}), 5000.5);
    t.is(parseValue('-5.000,5kg', {locale: 'it'}), -5000.5);
});

test('String: unparseable value', (t) => {
    t.is(parseValue('one'), NaN, 'string that cannot be parsed returns NaN');
});

test('Invalid types', (t) => {
    t.is(parseValue(null), NaN, 'null returns NaN');
    t.is(parseValue(), NaN, 'undefined returns NaN');
    t.is(parseValue(Infinity), NaN, 'Infinity returns NaN');
    t.is(parseValue(NaN), NaN, 'NaN returns NaN');
    t.is(parseValue([1, 2, 3]), NaN, 'array returns NaN');
    t.is(parseValue({value: 1}), NaN, 'object returns NaN');
});
